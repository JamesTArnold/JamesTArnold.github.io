<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="scripts.js"></script>
    <meta charset="utf-8">
    <title>Thoughts</title>
  </head>
  <body>
    <div class="topnav">
     <a href="#" class="active">About</a>
     <a href="../blog.html">Blog</a>
     <a href="#contact">Contact</a>
     <a href="javascript:void(0);" class="icon" onclick="myFunction()">
       <i class="fa fa-bars"></i>
     </a>
    </div>

    <div class="heading">
      <img src="chalkboard.jpg" alt="A picture of me" class="topimage">

      <div class="about">
        <h1><strong>General Problem-Solving Techniques</strong></h1>
      </div>
    </div>

    <div class="post">
      <h1></h1>
      <h2>Introduction</h2>
      <p>     My first post is going to be the foundation I set for myself when I
        first started learning to program. I am mainly doing this post so I can have a
        reference to the basic tenets of problem-solving in code. Most if not all of the following
        information comes from the book <a href="https://nostarch.com/thinklikeaprogrammer" target="_blank"> Think Like a Programmer by V. Anton Spraul</a>
         and is a good read if you are interested in this way of thinking. So without
         further adieu here is a poorly paraphrased post on Problem solving techniques in programming.
      </p>
      <h2>Always Have a Plan</h2>

      <p>     This is the most important rule out of all of these techniques. If you do not have a plan in your head you cannot implement a solution. General Dwight D. Eisenhower once said “I have always found that plans are useless, but planning is indispensable”. Through planning, you learn what your capabilities are, and how the different parts of your knowledge work together. Without a plan you are hoping for an uncommon lucky break. Planning also allows you to set intermediate goals and achieve them.</p>

      <h2>Restate the Problem</h2>

      <p>A problem that looks very difficult may seem easy when stated in a different way or using different terms. Restating a problem is like circling the base of a hill that you must climb; before starting your climb, why not check out the hill from every angle to see whether there's an easier way up? Restatement can also show us the goal was not what we thought it was. It can give you a chance to assess the goal and see if it fits with your overall plan. This strategy can also give you a little motivation. Without a plan, your only goal is to have working code, and restatement is taking time away from writing code. With a plan, you can put “formally restate the problem” as your first step; therefore, completing the restatement officially counts as progress.
      </p>

      <h2>Divide the Problem</h2>

      <p>     Finding a way to divide a problem into steps or phases can make the problem much easier. If you can divide a problem into two pieces, you might think that each piece would be half as difficult to solve as the original whole, but usually, it’s even easier than that. Some problems often hide their potential subdivision. Sometimes the way to find a problem’s divisions is to reduce the problem.</p>

      <h2>Start with What You Know</h2>

      <p>     The further away you get from your own experience the more difficult solving problems in that subject may be. You should try to start with what you already know how to do and work outward from there. Once you have divided the problem up into pieces go ahead and complete any pieces you already know how to do. Having a working partial solution may spark ideas about the rest of the problem. A common theme in problem solving is making useful progress to build confidence that you will ultimately complete the task. By starting with what you know, you build confidence and momentum toward the goal.
      </p>

      <h2>Reduce the Problem</h2>

      <p>     With this technique, when faced with a problem you are unable to solve, you reduce the scope of the problem, by either adding or removing constraints, to produce a problem that you do know how to solve. We know we are not working on the full problem, but the reduced problem has enough in common with the full problem that we will make progress toward the ultimate solution. Many times you will discover that you have all the individual skills necessary to solve the problem, and by tackling each individual aspect of a problem, you see how to combine the various pieces into a unified whole. Reducing the problem also allows us to pinpoint exactly where the remaining difficulty lies. This can also help you when you seek out experienced programmers for assistance, if you are unable to accurately describe the help that is needed it will be a headache for them to try and help.
      </p>

      <h2>Look for Analogies</h2>

      <p>     Look at the similarity between a current problem and a problem already solved that can be exploited to help solve the current problem.Recognizing analogies is the most important way you improve your speed and skill at problem solving. Do not try and find a shortcut by finding code that is similar to the needed code and modifying from there. If you don’t complete a solution yourself, You will not have fully understood and internalized it. It is very difficult to correctly modify a program that you don’t fully understand. Every successful program you write is more than a solution to a current problem; It’s a potential source of analogies to solve future problems. The more you rely on other programmers’ code now, the more you will have to rely on it in the future.
      </p>
      <h2>Experiment</h2>

      <p>     An experiment is a controlled process. You hypothesize what will happen when certain code is executed, try it out, and see whether your hypothesis is correct. From these observations, you gain information that will help you solve the original problem. Use experimentation when dealing with application programming interfaces or class libraries. Other forms of it are similar to debugging.
      </p>

      <h2>Don’t Get Frustrated</h2>

      <p>     When you are frustrated, you won’t think as clearly, you won’t work as effeciently, and everything will take longer and seem harder. Even worse, frustration tends to feed on itself, so that what begins mild irritation ends as outright anger. A frustrated programmer isn’t repsonding to an external stimulus. The frustrated programmer isn’t angry with source code on the monitor, although the programmer is angry at himself. The source of the frustration is also the destination, the programmer’s mind.</p>
      <p>     Avoiding frustration is a decision you must make. Never forget the first rule, that you should always have a plan, and that while writing code that solves the original problem is the goal of that plan, it is not the only step of that plan. Thus, if you have a plan and you’re following it, then you are making progress and you must believe this. If you’ve run through all the steps on your original plan and you’re still not ready to start coding, then it’s time to make another plan.</p>
      <p>     When it comes down to getting frustrated or taking a break, you take a break. One trick is to have more than one problem to work on so that if this one problem has you stymied, you can turn your efforts elsewhere. Note that if you successfully divide the problem, you can use this technique on a single problem; just block out the part of the problem that has you stuck, and work on something else. If you don’t have another problem you can tackle, get out of your chair and do something else, something that keeps your blood flowing but doesn’t make your brain hurt: take a walk, go through a stretching routine. Don’t think about the problem until the break is over.
      </p>

  </div>
  </body>
</html>
